#!/usr/bin/env python3
#
# Copyright (C) 2021 Vladimir Berlev
#
# SPDX-License-Identifier: MIT

import argparse
import logging
import os
import shutil
import subprocess

TARGET_IMAGE = '127.0.0.1:5000/anide'
CONTAINER_NAME = 'anide'


class AnIde:
    def __init__(self, args):
        self.args = args
        self.docker = AnIde.get_docker()
        self.build_context = AnIde.get_build_context()

    @staticmethod
    def get_build_context():
        if not '__file__' in globals():
            raise RuntimeError('__file__ is not defined')

        path = os.path.join(
            os.path.dirname(os.path.realpath(__file__)), 
            'image'
        )
        if not os.path.exists(path):
            raise RuntimeError(f'{path} does not exist')

        # sanity check:
        # Dockerfile should be present in the build context
        dockerfile = os.path.join(path, 'Dockerfile')
        if not os.path.exists(dockerfile):
            raise RuntimeError(f'{dockerfile} does not exist')

        return path

    @staticmethod
    def get_docker():
        path = shutil.which('docker')
        if path is None:
            raise RuntimeError('docker is not found on the system')
        return path

    def main(self):
        logging.debug(self.args)
        if self.args.command == 'build':
            self.build()
        elif self.args.command == 'run':
            self.run()
        elif self.args.command == 'stop':
            self.stop()
        elif self.args.command == 'attach':
            self.attach()

    def build(self):
        self._run([
            self.docker, 'build', 
            '-t', TARGET_IMAGE,
            self.build_context
        ])

    def run(self):
        self._run([
            self.docker, 'run', 
            '--name', CONTAINER_NAME, 
            '--detach', 
            '--pull', 'never', 
            '--rm', 
            TARGET_IMAGE
        ])

    def stop(self):
        self._run([self.docker, 'stop', CONTAINER_NAME])

    def attach(self):
        self._run([self.docker, 'exec', '-it', CONTAINER_NAME, '/bin/bash'])

    def _run(self, command):
        workdir = self.build_context
        logging.info(f'workdir: {workdir}')
        logging.info(f'command: {command}')
        if not self.args.dry_run:
            subprocess.run(command, cwd=workdir)


def parse_args():
    p = argparse.ArgumentParser(
        description='An IDE',
        epilog='Copyright (C) 2021 Vladimir Berlev, MIT License'
    )
    p.add_argument('-v', '--verbose', action='store_true')
    p.add_argument('--dry-run', action='store_true')
    sp = p.add_subparsers(metavar='COMMAND', dest='command', required=True)
    sp.add_parser('build', help='build an IDE')
    sp.add_parser('run', help='run an IDE')
    sp.add_parser('stop', help='stop an IDE')
    sp.add_parser('attach', help='attach to an IDE')
    return p.parse_args()


def setup_logging(args):
    level = logging.DEBUG if args.verbose else logging.INFO
    logging.basicConfig(level=level, format='%(levelname)-6s: %(message)s')


if __name__ == '__main__':
    args = parse_args()
    setup_logging(args)
    try:
        AnIde(args).main()
    except Exception as e:
        logging.error(str(e))

